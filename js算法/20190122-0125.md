# 题目（this指向问题）

**题目一：如下代码打印什么？**
```javascript
unction foo(num) {
  console.log( "foo: " + num );
  this.count++;
}
foo.count = 0;
for (var i=0; i<10; i++) {
  if (i > 5) {
    foo( i );
  }
}
console.log( foo.count );
```
**答案：**

    foo: 6 <br/>
    foo: 7 <br/>
    foo: 8 <br/>
    foo: 9 <br/>
    0 <br/>

**问题解析：**

foo：6789这个打印应该都没有问题，至于最后foo.count为啥是0，因为当循环调用foo时，方法内的this并不是指向foo而是window,所以foo.count并没有发生改变；

// 任民答案
    foo: 6
    foo: 7
    foo: 8
    foo: 9
    0



**题目二：如下代码打印什么？**
```javascript
function fn(num) {
  console.log( "fn: " + num );
  console.log('count1::'+ this.count);
  this.count++;
  console.log('count2::'+ this.count);
}
fn.count = 0;
var i;
for (i=0; i<3; i++) {
  fn( i );
}
console.log( fn.count );
```
//打印结果<br/>
fn: 0<br/>
count1::undefined<br/>
count2::NaN<br/>
fn: 1<br/>
count1::NaN<br/>
count2::NaN<br/>
fn: 2<br/>
count1::NaN<br/>
count2::NaN<br/>
0<br/>

**小兜的解释:**

因为是在全局调用的fn，所以函数里this就是window，window.count未定义一直都是undefind，然后做了自增就变成NAN了，NAN自增还是NAN

**题目三：如下代码打印什么？**
```javascript
var a = 5;
function foo() {
    console.log( this.a );
}
var obj2 = {
    a: 42,
    foo: foo
};
var obj1 = {
    a: 2,
    obj2: obj2
};
obj1.obj2.foo();
```
答案：42<br/>
解析：this只对直接调用者负责，obj2是直接调用者

个人回答情况：<br/>
阿超/阿冬  2<br/>
阿成/阿丽/小谢  42

**题目四：如下代码打印什么？**
```javascript
var b=5;
function foo(){
  console.log(this.b);
}
var obj1= {
  b:42,
  foo:function(){
    this.b=1;
    foo();
  }
}
obj1.foo();
```
答案：5 <br/>
解析：<br/>
虽然obj1引用了函数foo()，但是foo()执行的就是刚开始的函数声明时的foo，没有obj1里面的任何参数参与，所以this的指向应该是window

**题目五：如下代码打印什么？**
```
function foo() {
  console.log( this.a );
}
var a = 2;
foo.a = 5;
foo.call( null );
```
答案：undefined <br/>
解析：<br/>
call直接将this指向变成了null

* [你不知道的this指向](../主题分享/分享文档/你不知道的this指向.pptx)