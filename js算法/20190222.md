# 题目

Promise是什么？如何使用？<br>
### 问题：
1.Promise对象有哪些状态？<br>
2.如何创建一个Promise对象？<br>
3.runAsyncFun().then(...)<br>
4.runAsyncFun().then(...).catch(...)<br>
5.Promise.all <br>
6.Promise.race <br>
7.Promise 跟aysnc awaite有啥区别
## 答案
我相信每个前端都遇到过这样一个问题，当一个异步任务的执行需要依赖另一个异步任务的结果时，我们一般会将两个异步任务嵌套起来，这种情况发生一两次还可以忍，但是发生很多次之后，你的代码就会变成这个熊样：<br>
```javascript
async1(function(){
    async2(function(){
        async3(function(
            async4(funciton(){
                async5(function(){
                    //...
                });
            });
        ));
    });
});
```
### Promise对象的状态
```javascript
Promise 对象代表一个异步操作，其不受外界影响，有三种状态：
Pending（进行中、未完成的）
Resolved（已完成，又称 Fulfilled）
Rejected（已失败）
（1）promise 从未完成的状态开始，如果成功它将会是完成态，如果失败将会是失败态。
（2）当一个 promise 移动到完成态，所有注册到它的成功回调将被调用，而且会将成功的结果值传给它。另外，任何注册到 promise 的成功回调，将会在它已经完成以后立即被调用。
（3）同样的，当一个 promise 移动到失败态的时候，它调用的是失败回调而不是成功回调。
（4）对包含前进特性的实现来说，promise 在它离开未完成状态以前的任何时刻，都可以更新它的 progress。当 progress 被更新，所有的前进回调(progress callbacks)会被传递以 progress 的值，并被立即调用。前进回调被以不同于成功和失败回调的方式处理；如果你在一个 progress 更新已经发生以后注册了一个前进回调，新的前进回调只会在它被注册以后被已更新的 progress 调用。
（5）注意：只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。
```
### 创建Promise对象
新建一个Promise的实例，如下：<br>
```javascript
var _promise = new Promise(function(resolve, reject){
    setTimeout(function(){
        var rand = Math.random();
        if(rand<0.5){
            resolve("resolve" + rand);
        }else{
            reject("reject" + rand);
        }
    },1000);
});
// 由上所示，Promise的构造函数接收一个函数作为参数，该函数接受两个额外的函数，resolve和reject，这两个函数分别代表将当前Promise置为fulfilled(解决)和rejected(拒绝)两个状态。Promise正是通过这两个状态来控制异步操作的结果。接下来我们将讨论Promise的用法，实际上Promise上的实例_promise是一个对象，不是一个函数。在声明的时候，Promise传递的参数函数会立即执行，因此Promise使用的正确姿势是在其外层再包裹一层函数。
```

```javascript
var runAsync= function(){
    var _promise = new Promise(function(resolve, reject){
        setTimeout(function(){
            var rand = Math.random();
            if(rand<0.5){
                resolve("resolve" + rand);
            }else{
                reject("reject" + rand);
            }
        },1000);
    });
    return _promise;
}
runAsync();
// 这是Promise的正常用法，接下来，就是对异步操作结果的处理，接着上面创建的函数runAsync()
 runAsync().then(function(data){
    console.log(data);
});
// ------------------------------------------------------------------------------------------------------------------------------
runAsync().then(function(data){
    //处理resolve的代码
    cosnole.log(data);
},function(data){
    //处理reject的代码
    cosnole.log(data);
})
// 每个Promise的实例对象，都有一个then的方法，这个方法就是用来处理之前各种异步逻辑的结果。 这时候你会发现，原来then里面的函数就跟我们平时的回调函数一个意思，能够在runAsync这个异步任务执行完成之后被执行。这就是Promise的作用了，简单来讲，就是能把原来的回调写法分离出来，在异步操作执行完后，用链式调用的方式执行回调函数。
// 然而你可能会不屑一顾，那么牛逼轰轰的Promise就这点能耐？我把回调函数封装一下，给runAsync传进去不也一样吗，就像这样：
function runAsync(callback){
    setTimeout(function(){
        console.log('执行完成');
        callback('runAsync');
    }, 2000);
}

runAsync(function(data){
    console.log(data);
});
// 效果也是一样的，还费劲用Promise干嘛。那么问题来了，有多层回调该怎么办？如果callback也是一个异步操作，而且执行完后也需要有相应的回调函数，该怎么办呢？总不能再定义一个callback2，然后给callback传进去吧。而Promise的优势在于，可以在then方法中继续写Promise对象并返回，然后继续调用then来进行回调操作。
```
### 链式操作的用法：
所以，从表面上看，Promise只是能够简化层层回调的写法，而实质上，Promise的精髓是“状态”，用维护状态、传递状态的方式来使得回调函数能够及时调用，它比传递callback函数要简单、灵活的多。所以使用Promise的正确场景是这样的.
```javascript
runAsync1()
.then(function(data){
    console.log(data);
    return runAsync2();
})
.then(function(data){
    console.log(data);
    return runAsync3();
})
.then(function(data){
    console.log(data);
});
// 这样能够按顺序，每隔两秒输出每个异步回调中的内容，在runAsync2中传给resolve的数据，能在接下来的then方法中拿到.......
// 在then方法中，你也可以直接return数据而不是Promise对象，在后面的then中就可以接收到数据了
```
### catch的用法：
我们知道Promise对象除了then方法，还有一个catch方法，它是做什么用的呢？其实它和then的第二个参数一样，用来指定reject的回调，用法是这样：
```javascript
runAsync()
.then(function(data){
    console.log('resolved');
    console.log(data);
})
.catch(function(reason){
    console.log('rejected');
    console.log(reason);
});
// 效果和写在then的第二个参数里面一样。不过它还有另外一个作用：在执行resolve的回调（也就是上面then中的第一个参数）时，如果抛出异常了（代码出错了），那么并不会报错卡死js，而是会进到这个catch方法中。请看下面的代码：
runAsync()
.then(function(data){
    console.log('resolved');
    console.log(data); // 假设此处data=1
    console.log(somedata); // 此处的somedata未定义
})
.catch(function(reason){
    console.log('rejected');
    console.log(reason);
});
// 在resolve的回调中，我们console.log(somedata);而somedata这个变量是没有被定义的。如果我们不用Promise，代码运行到这里就直接在控制台报错了，不往下运行了。但是在这里，会得到这样的结果：
resolved
1
rejected
ReferenceError: somedata is not defined
```
### all的用法
Promise的all方法提供了并行执行异步操作的能力，并且在所有异步操作执行完后才执行回调。我们仍旧使用上面定义好的runAsync1、runAsync2、runAsync3这三个函数，看下面的例子：
```javascript
Promise.all([runAsync1(), runAsync2(), runAsync3()])
.then(function(results){
    console.log(results);
});
// 用Promise.all来执行，all接收一个数组参数，里面的值最终都算返回Promise对象。这样，三个异步操作的并行执行的，等到它们都执行完后才会进到then里面。那么，三个异步操作返回的数据哪里去了呢？都在then里面呢，all会把所有异步操作的结果放进一个数组中传给then，就是上面的results。所以上面代码的输出结果就是：
执行完成
runAsync1
执行完成
runAsync2
执行完成
runAsync3
["runAsync1","runAsync2","runAsync3"]
// 有了all，你就可以并行执行多个异步操作，并且在一个回调中处理所有的返回数据，是不是很酷？有一个场景是很适合用这个的，一些游戏类的素材比较多的应用，打开网页时，预先加载需要用到的各种资源如图片、flash以及各种静态文件。所有的都加载完后，我们再进行页面的初始化。
// 注意： Promise.all执行多个的时候，如果有一个reject就都走reject了，要想在失败的时候也走then需要特殊处理一下
```
### race的用法：
all方法的效果实际上是「谁跑的慢，以谁为准执行回调」，那么相对的就有另一个方法「谁跑的快，以谁为准执行回调」，这就是race方法，这个词本来就是赛跑的意思。race的用法与all一样。<br>
在then里面的回调开始执行时，假设runAsync1() 先执行完， 其实runAsync2()和runAsync3()并没有停止，仍旧在执行。
### async和await
async和await在干什么，async用于申明一个function是异步的，而await可以认为是async wait的简写，等待一个异步方法执行完成。
```javascript
async function demo(params) {
   // ...
}

demo()
// async返回的是一个Promise对象。
// 在Chrome里申明这样一个函数，可以在控制台看到返回的其实就是一个Promise对象，如下图
```
![](../images/code-console.png)
```javascript
// await会阻塞当前直到完成
const test = await demo();
const test1 = await demo1();
//注： demo执行完成后才会执行demo1

// await/async与Promise的简单应用：
function getJSON1 () {
    return new Promise(function (resolve, reject) {
        // ajax...
    })
}
function getJSON2() {
    return new Promise(function (resolve, reject) {
        // ajax...
    })
}
async function asyncBuildParams (params) {
    const newParams = params
    newParams.jSON1= await jSON1()
    newParams.jSON2= await jSON2()
    return newParams
}
const params = asyncBuildParams(params)
```
* [参考ES6-Promise用法讲解](<https://www.cnblogs.com/whybxy/p/7645578.html>)
* [参考JS-Promise使用详解](<https://www.cnblogs.com/sweeeper/p/8442613.html>)
* [参考资料](<https://www.jianshu.com/p/fe0159f8beb4>)